// Generated by CoffeeScript 1.11.1
var Complexe, Fraction, Point, Vecteur, Znot, bincross, binpixels, chronomètre, deux_chiffres, differenceFractions, egypt, entexte, ndiz, nmille, nmillesingulier, nunit, pgcd, produitFractions, quotientFractions, quotronc, sommeFractions, toMath, trois_chiffres, truchet, truchetgrille, truchetgrille2, truchetortho, truchetpixels, truchetrond;

Boolean.prototype.toLocaleString = function() {
  if (this.valueOf()) {
    return " c'est vrai ";
  } else {
    return " c'est pas vrai ";
  }
};

pgcd = function(x, y) {
  var ref;
  while (y !== 0) {
    ref = [y, x % y], x = ref[0], y = ref[1];
  }
  return x;
};

Fraction = (function() {
  function Fraction(n1, d1) {
    var facteur, ref;
    this.n = n1 != null ? n1 : 1;
    this.d = d1 != null ? d1 : 1;
    facteur = pgcd(this.n, this.d);
    this.n /= facteur;
    this.d /= facteur;
    if (this.d < 0) {
      ref = [-this.n, -this.d], this.n = ref[0], this.d = ref[1];
    }
  }

  return Fraction;

})();

Fraction.prototype.toString = function() {
  if (this.d === 1) {
    return "" + this.n;
  } else {
    if (this.n / this.d < 0) {
      return "(-" + (-this.n) + "/" + this.d + ")";
    } else {
      return this.n + "/" + this.d;
    }
  }
};

Fraction.prototype.plus = function(autre) {
  if ((autre != null ? autre.n : void 0) && (autre != null ? autre.d : void 0)) {
    return new Fraction(this.n * autre.d + this.d * autre.n, this.d * autre.d);
  }
};

Fraction.prototype.moins = function(autre) {
  if ((autre != null ? autre.n : void 0) && (autre != null ? autre.d : void 0)) {
    return new Fraction(this.n * autre.d - this.d * autre.n, this.d * autre.d);
  }
};

Fraction.prototype.fois = function(autre) {
  if ((autre != null ? autre.n : void 0) && (autre != null ? autre.d : void 0)) {
    return new Fraction(this.n * autre.n, this.d * autre.d);
  }
};

Fraction.prototype.sur = function(autre) {
  if ((autre != null ? autre.n : void 0) && (autre != null ? autre.d : void 0)) {
    return new Fraction(this.n * autre.d, this.d * autre.n);
  }
};

Fraction.prototype.inverse = function() {
  return new Fraction(this.d, this.n);
};

Fraction.prototype.opposé = function() {
  return new Fraction(-this.n, this.d);
};

Fraction.prototype.toFloat = function() {
  return this.n / this.d;
};

sommeFractions = function(f1, f2) {
  return new Fraction(f1.n * f2.d + f1.d * f2.n, f1.d * f2.d);
};

differenceFractions = function(f1, f2) {
  return new Fraction(f1.n * f2.d - f1.d * f2.n, f1.d * f2.d);
};

produitFractions = function(f1, f2) {
  return new Fraction(f1.n * f2.n, f1.d * f2.d);
};

quotientFractions = function(f1, f2) {
  return new Fraction(f1.n * f2.d, f1.d * f2.n);
};

Complexe = (function() {
  function Complexe(Re, Im) {
    this.Re = Re != null ? Re : 1;
    this.Im = Im != null ? Im : 0;
  }

  return Complexe;

})();

Complexe.prototype.toString = function() {
  if (this.Im < 0) {
    return this.Re + "-" + (-this.Im) + "i";
  } else {
    return this.Re + "+" + this.Im + "i";
  }
};

Complexe.prototype.plus = function(z) {
  return new Complexe(this.Re + z.Re, this.Im + z.Im);
};

Complexe.prototype.moins = function(z) {
  return new Complexe(this.Re - z.Re, this.Im - z.Im);
};

Complexe.prototype.fois = function(z) {
  return new Complexe(this.Re * z.Re - this.Im * z.Im, this.Re * z.Im + this.Im * z.Re);
};

Complexe.prototype.conj = function() {
  return new Complexe(this.Re, -this.Im);
};

Complexe.prototype.modCarre = function() {
  return (this.fois(this.conj())).Re;
};

Complexe.prototype.module = function() {
  return Math.sqrt(this.modCarre());
};

Complexe.prototype.argument = function() {
  return Math.atan2(this.Im, this.Re);
};

Complexe.prototype.inverse = function() {
  return new Complexe(this.Re / this.modCarre(), -this.Im / this.modCarre());
};

Complexe.prototype.sur = function(z) {
  return this.fois(z.inverse());
};

Point = (function() {
  function Point(x1, y1) {
    this.x = x1 != null ? x1 : 0;
    this.y = y1 != null ? y1 : 0;
  }

  return Point;

})();

Point.prototype.toString = function() {
  return "(" + this.x + ";" + this.y + ")";
};

Point.prototype.milieu = function(autre) {
  if ((autre != null ? autre.x : void 0) && (autre != null ? autre.y : void 0)) {
    return new Point((this.x + autre.x) / 2, (this.y + autre.y) / 2);
  }
};

Point.prototype.vecteur = function(autre) {
  if ((autre != null ? autre.x : void 0) && (autre != null ? autre.y : void 0)) {
    return new Vecteur(autre.x - this.x, autre.y - this.y);
  }
};

Point.prototype.distance = function(autre) {
  if ((autre != null ? autre.x : void 0) && (autre != null ? autre.y : void 0)) {
    return (this.vecteur(autre)).norme();
  }
};

Vecteur = (function() {
  function Vecteur(x1, y1) {
    this.x = x1 != null ? x1 : 0;
    this.y = y1 != null ? y1 : 0;
  }

  return Vecteur;

})();

Vecteur.prototype.toString = function() {
  return "(" + this.x + ";" + this.y + ")";
};

Vecteur.prototype.norme = function() {
  return racine(this.x * this.x + this.y * this.y);
};

Vecteur.prototype.plus = function(v) {
  if ((v != null ? v.x : void 0) && (v != null ? v.y : void 0)) {
    return new Vecteur(this.x + v.x, this.y + v.y);
  }
};

Vecteur.prototype.scalaire = function(v) {
  if ((v != null ? v.x : void 0) && (v != null ? v.y : void 0)) {
    return this.x * v.x + this.y * v.y;
  }
};

Vecteur.prototype.fois = function(nombre) {
  return new Vecteur(this.x * nombre, this.y * nombre);
};

Vecteur.prototype.déterminant = function(v) {
  if ((v != null ? v.x : void 0) && (v != null ? v.y : void 0)) {
    return this.x * v.y - this.y * v.x;
  }
};

Vecteur.prototype.colinéaireAvec = function(v) {
  if ((v != null ? v.x : void 0) && (v != null ? v.y : void 0)) {
    return (this.déterminant(v)) === 0;
  }
};

Vecteur.prototype.orthogonal = function(v) {
  if ((v != null ? v.x : void 0) && (v != null ? v.y : void 0)) {
    return (this.scalaire(v)) === 0;
  }
};

chronomètre = function(func) {
  var _start, _stop, i, n;
  _start = new Date();
  for (n = i = 1; i <= 1000000; n = ++i) {
    eval(func);
  }
  _stop = new Date();
  return (_stop - _start) + " µs";
};

egypt = function(uneFraction) {
  var e, f, réduites;
  f = uneFraction;
  e = troncature(f.toFloat());
  f = f.moins(new Fraction(e, 1));
  réduites = [e];
  while (f.n !== 1) {
    e = new Fraction(1, arrondiSup(f.inverse().toFloat()));
    réduites.push(e);
    f = f.moins(e);
  }
  réduites.push(f);
  return réduites;
};

nunit = ["zéro", "et-un", "deux", "trois", "quatre", "cinq", "six", "sept", "huit", "neuf", "dix", "onze", "douze", "treize", "quatorze", "quinze", "seize", "dix-sept", "dix-huit", "dix-neuf"];

ndiz = ["zéro", "dix", "vingt", "trente", "quarante", "cinquante", "soixante", "soixante", "quatre-vingt", "quatre-vingt"];

nmillesingulier = ["zéro", "mille", "million", "milliard", "billion", "billiard", "trillion", "trillard", "quadrillion", "quadrillard", "quintillion", "quintilliard", "sextillion", "sextilliard"];

nmille = ["zéro", "mille", "millions", "milliards", "billions", "billiards", "trillions", "trillards", "quadrillions", "quadrillards", "quintillions", "quintilliards", "sextillions", "sextilliards"];

quotronc = function(n, d) {
  return Math.floor(n / d);
};

deux_chiffres = function(n) {
  if (n === 0) {
    return "";
  } else {
    if (n === 71) {
      return "soixante-et-onze";
    } else {
      if (n === 1) {
        return "un";
      } else {
        if (n < 20) {
          return nunit[n];
        } else {
          if (n < 60) {
            if (n % 10 === 0) {
              return ndiz[quotronc(n, 10)];
            } else {
              return ndiz[quotronc(n, 10)] + "-" + nunit[n % 10];
            }
          } else {
            if (n % 20 === 0) {
              return ndiz[quotronc(n, 10)];
            } else {
              if (n % 20 === 1) {
                return ndiz[quotronc(n, 10)] + "-" + nunit[n % 20];
              } else {
                return ndiz[quotronc(n, 10)] + "-" + nunit[n % 20];
              }
            }
          }
        }
      }
    }
  }
};

trois_chiffres = function(n) {
  if (n < 100) {
    return deux_chiffres(n);
  } else {
    if (n < 200) {
      return "cent " + deux_chiffres(n % 100);
    } else {
      return nunit[quotronc(n, 100)] + " cents " + deux_chiffres(n % 100);
    }
  }
};

entexte = function(n) {
  var N, indice, texte;
  N = n.toString().length;
  N = quotronc(N - 1, 3);
  if (N === 0) {
    return trois_chiffres(n);
  } else {
    if (N === 1) {
      if (n < 2000) {
        return nmille[N] + " " + trois_chiffres(n % 1000);
      } else {
        return trois_chiffres(quotronc(n, 1000)) + " " + nmille[N] + " " + trois_chiffres(n % 1000);
      }
    } else {
      texte = trois_chiffres(n % 1000);
      n = quotronc(n, 1000);
      indice = 1;
      while (indice <= N) {
        if (n % 1000 > 0) {
          if (n % 1000 === 1) {
            texte = " un " + nmillesingulier[indice] + " " + texte;
          } else {
            texte = trois_chiffres(n % 1000) + " " + nmille[indice] + " " + texte;
          }
        }
        n = quotronc(n, 1000);
        indice += 1;
      }
      return texte;
    }
  }
};

Znot = {
  ".inter ": "∩",
  ".intersectionWith ": "∩",
  ".union ": "∪",
  " not in ": "∉",
  " in ": "∈",
  "racine": "√",
  "Math.sqrt": "√",
  "laRacineDe": "√",
  "Infinity": "∞",
  "=": "←",
  "!←": "≠",
  "←←": "=",
  "<←": "≤",
  ">←": "≥",
  "/←": " est divisé par ",
  "\\*←": " est multiplié par ",
  "-←": " est diminué de ",
  "\\+←": " est augmenté de ",
  "\\+\\+": " est incrémenté",
  "--": "est décrémenté",
  " dans ": "∈",
  ".estVide\\(\\)": "=∅",
  ".contains": " ∋ ",
  ".isPerpendicularTo": " ⟂",
  ".isParallelTo": " ∥ ",
  ".subtract": " -",
  ".every": "∀",
  ".some": "∃",
  ".complémentDans": " ∖",
  "->": "↦",
  ".push": " ⇦",
  ".empile": " ⇦",
  ".pop\\(\\)": " ⇨",
  ".ajoute": " ⇦",
  "laSommeDe": "∑",
  ".dot": ".",
  ".angleFrom": "∠",
  ".multiply": "×",
  ".add": "+",
  ".subtract": "-",
  "lEcartTypeDe": "σ",
  "Math.E": "ℯ",
  "for ": "pour ",
  "until ": "jusqu\'à ce que ",
  "while ": "tant que ",
  "if ": "si ",
  "else": "sinon"
};

toMath = function(cs) {
  _.each(Znot, function(value, key) {
    var re;
    re = new RegExp(key, 'g');
    return cs = cs.replace(re, value);
  });
  cs = cs.replace(/\[(\d+)\.\.(\d+)\]/g, "〚$1,$2〛");
  return cs;
};

truchetrond = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "╮╰");
  t = t.replace(/1/g, "╯╭");
  return t;
};

truchet = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "╲");
  t = t.replace(/1/g, "╱");
  return t;
};

truchetortho = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "━");
  t = t.replace(/1/g, "┃");
  return t;
};

truchetgrille = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "╪");
  t = t.replace(/1/g, "╫");
  return t;
};

truchetgrille2 = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "┿");
  t = t.replace(/1/g, "╂");
  return t;
};

truchetpixels = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "▚");
  t = t.replace(/1/g, "▞");
  return t;
};

bincross = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "☐");
  t = t.replace(/1/g, "☒");
  return t;
};

binpixels = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "⬜");
  t = t.replace(/1/g, "⬛");
  return t;
};
