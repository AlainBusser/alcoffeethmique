// Generated by CoffeeScript 2.3.0
var Complexe, Fraction, Point, Vecteur, Znot, bincross, binpixels, calligraphique, chronomètre, deux_chiffres, differenceFractions, egypt, entexte, est_majuscule, est_minuscule, ndiz, nmille, nmillesingulier, nunit, pgcd, produitFractions, quotientFractions, quotronc, sommeFractions, toMath, trois_chiffres, truchet, truchetgrille, truchetgrille2, truchetortho, truchetpixels, truchetrond;

Boolean.prototype.toLocaleString = function() {
  if (this.valueOf()) {
    return " c'est vrai ";
  } else {
    return " c'est pas vrai ";
  }
};

pgcd = function(x, y) {
  while (y !== 0) {
    [x, y] = [y, x % y];
  }
  return x;
};

Fraction = class Fraction {
  constructor(n1 = 1, d1 = 1) {
    var facteur;
    this.n = n1;
    this.d = d1;
    facteur = pgcd(this.n, this.d);
    this.n /= facteur;
    this.d /= facteur;
    if (this.d < 0) {
      [this.n, this.d] = [-this.n, -this.d];
    }
  }

};

Fraction.prototype.toString = function() {
  if (this.d === 1) {
    return `${this.n}`;
  } else {
    if (this.n / this.d < 0) {
      return `(-${-this.n}/${this.d})`;
    } else {
      return `${this.n}/${this.d}`;
    }
  }
};

Fraction.prototype.plus = function(autre) {
  if ((autre != null ? autre.n : void 0) && (autre != null ? autre.d : void 0)) {
    return new Fraction(this.n * autre.d + this.d * autre.n, this.d * autre.d);
  }
};

Fraction.prototype.moins = function(autre) {
  if ((autre != null ? autre.n : void 0) && (autre != null ? autre.d : void 0)) {
    return new Fraction(this.n * autre.d - this.d * autre.n, this.d * autre.d);
  }
};

Fraction.prototype.fois = function(autre) {
  if ((autre != null ? autre.n : void 0) && (autre != null ? autre.d : void 0)) {
    return new Fraction(this.n * autre.n, this.d * autre.d);
  }
};

Fraction.prototype.sur = function(autre) {
  if ((autre != null ? autre.n : void 0) && (autre != null ? autre.d : void 0)) {
    return new Fraction(this.n * autre.d, this.d * autre.n);
  }
};

Fraction.prototype.inverse = function() {
  return new Fraction(this.d, this.n);
};

Fraction.prototype.opposé = function() {
  return new Fraction(-this.n, this.d);
};

Fraction.prototype.toFloat = function() {
  return this.n / this.d;
};

sommeFractions = function(f1, f2) {
  return new Fraction(f1.n * f2.d + f1.d * f2.n, f1.d * f2.d);
};

differenceFractions = function(f1, f2) {
  return new Fraction(f1.n * f2.d - f1.d * f2.n, f1.d * f2.d);
};

produitFractions = function(f1, f2) {
  return new Fraction(f1.n * f2.n, f1.d * f2.d);
};

quotientFractions = function(f1, f2) {
  return new Fraction(f1.n * f2.d, f1.d * f2.n);
};

Complexe = class Complexe {
  constructor(Re = 1, Im = 0) {
    this.Re = Re;
    this.Im = Im;
  }

};

Complexe.prototype.toString = function() {
  if (this.Im < 0) {
    return `${this.Re}-${-this.Im}i`;
  } else {
    return `${this.Re}+${this.Im}i`;
  }
};

Complexe.prototype.plus = function(z) {
  return new Complexe(this.Re + z.Re, this.Im + z.Im);
};

Complexe.prototype.moins = function(z) {
  return new Complexe(this.Re - z.Re, this.Im - z.Im);
};

Complexe.prototype.fois = function(z) {
  return new Complexe(this.Re * z.Re - this.Im * z.Im, this.Re * z.Im + this.Im * z.Re);
};

Complexe.prototype.conj = function() {
  return new Complexe(this.Re, -this.Im);
};

Complexe.prototype.modCarre = function() {
  return (this.fois(this.conj())).Re;
};

Complexe.prototype.module = function() {
  return Math.sqrt(this.modCarre());
};

Complexe.prototype.argument = function() {
  return Math.atan2(this.Im, this.Re);
};

Complexe.prototype.inverse = function() {
  return new Complexe(this.Re / this.modCarre(), -this.Im / this.modCarre());
};

Complexe.prototype.sur = function(z) {
  return this.fois(z.inverse());
};

Point = class Point {
  constructor(x1 = 0, y1 = 0) {
    this.x = x1;
    this.y = y1;
  }

};

Point.prototype.toString = function() {
  return `(${this.x};${this.y})`;
};

Point.prototype.milieu = function(autre) {
  if ((autre != null ? autre.x : void 0) && (autre != null ? autre.y : void 0)) {
    return new Point((this.x + autre.x) / 2, (this.y + autre.y) / 2);
  }
};

Point.prototype.vecteur = function(autre) {
  if ((autre != null ? autre.x : void 0) && (autre != null ? autre.y : void 0)) {
    return new Vecteur(autre.x - this.x, autre.y - this.y);
  }
};

Point.prototype.distance = function(autre) {
  if ((autre != null ? autre.x : void 0) && (autre != null ? autre.y : void 0)) {
    return (this.vecteur(autre)).norme();
  }
};

Vecteur = class Vecteur {
  constructor(x1 = 0, y1 = 0) {
    this.x = x1;
    this.y = y1;
  }

};

Vecteur.prototype.toString = function() {
  return `(${this.x};${this.y})`;
};

Vecteur.prototype.norme = function() {
  return racine(this.x * this.x + this.y * this.y);
};

Vecteur.prototype.plus = function(v) {
  if ((v != null ? v.x : void 0) && (v != null ? v.y : void 0)) {
    return new Vecteur(this.x + v.x, this.y + v.y);
  }
};

Vecteur.prototype.scalaire = function(v) {
  if ((v != null ? v.x : void 0) && (v != null ? v.y : void 0)) {
    return this.x * v.x + this.y * v.y;
  }
};

Vecteur.prototype.fois = function(nombre) {
  return new Vecteur(this.x * nombre, this.y * nombre);
};

Vecteur.prototype.déterminant = function(v) {
  if ((v != null ? v.x : void 0) && (v != null ? v.y : void 0)) {
    return this.x * v.y - this.y * v.x;
  }
};

Vecteur.prototype.colinéaireAvec = function(v) {
  if ((v != null ? v.x : void 0) && (v != null ? v.y : void 0)) {
    return (this.déterminant(v)) === 0;
  }
};

Vecteur.prototype.orthogonal = function(v) {
  if ((v != null ? v.x : void 0) && (v != null ? v.y : void 0)) {
    return (this.scalaire(v)) === 0;
  }
};

chronomètre = function(func) {
  var _start, _stop, i, n;
  _start = new Date();
  for (n = i = 1; i <= 1000000; n = ++i) {
    eval(func);
  }
  _stop = new Date();
  return `${_stop - _start} µs`;
};

egypt = function(uneFraction) {
  var e, f, réduites;
  f = uneFraction;
  e = troncature(f.toFloat());
  f = f.moins(new Fraction(e, 1));
  réduites = [e];
  while (f.n !== 1) {
    e = new Fraction(1, arrondiSup(f.inverse().toFloat()));
    réduites.push(e);
    f = f.moins(e);
  }
  réduites.push(f);
  return réduites;
};

nunit = ["zéro", "et-un", "deux", "trois", "quatre", "cinq", "six", "sept", "huit", "neuf", "dix", "onze", "douze", "treize", "quatorze", "quinze", "seize", "dix-sept", "dix-huit", "dix-neuf"];

ndiz = ["zéro", "dix", "vingt", "trente", "quarante", "cinquante", "soixante", "soixante", "quatre-vingt", "quatre-vingt"];

nmillesingulier = ["zéro", "mille", "million", "milliard", "billion", "billiard", "trillion", "trillard", "quadrillion", "quadrillard", "quintillion", "quintilliard", "sextillion", "sextilliard"];

nmille = ["zéro", "mille", "millions", "milliards", "billions", "billiards", "trillions", "trillards", "quadrillions", "quadrillards", "quintillions", "quintilliards", "sextillions", "sextilliards"];

quotronc = function(n, d) {
  return Math.floor(n / d);
};

deux_chiffres = function(n) {
  if (n === 0) {
    return "";
  } else {
    if (n === 71) {
      return "soixante-et-onze";
    } else {
      if (n === 1) {
        return "un";
      } else {
        if (n < 20) {
          return nunit[n];
        } else {
          if (n < 60) {
            if (n % 10 === 0) {
              return ndiz[quotronc(n, 10)];
            } else {
              return ndiz[quotronc(n, 10)] + "-" + nunit[n % 10];
            }
          } else {
            if (n % 20 === 0) {
              return ndiz[quotronc(n, 10)];
            } else {
              if (n % 20 === 1) {
                return ndiz[quotronc(n, 10)] + "-" + nunit[n % 20];
              } else {
                return ndiz[quotronc(n, 10)] + "-" + nunit[n % 20];
              }
            }
          }
        }
      }
    }
  }
};

trois_chiffres = function(n) {
  if (n < 100) {
    return deux_chiffres(n);
  } else {
    if (n < 200) {
      return "cent " + deux_chiffres(n % 100);
    } else {
      return nunit[quotronc(n, 100)] + " cents " + deux_chiffres(n % 100);
    }
  }
};

entexte = function(n) {
  var N, indice, texte;
  N = n.toString().length;
  N = quotronc(N - 1, 3);
  if (N === 0) {
    return trois_chiffres(n);
  } else {
    if (N === 1) {
      if (n < 2000) {
        return nmille[N] + " " + trois_chiffres(n % 1000);
      } else {
        return trois_chiffres(quotronc(n, 1000)) + " " + nmille[N] + " " + trois_chiffres(n % 1000);
      }
    } else {
      texte = trois_chiffres(n % 1000);
      n = quotronc(n, 1000);
      indice = 1;
      while (indice <= N) {
        if (n % 1000 > 0) {
          if (n % 1000 === 1) {
            texte = " un " + nmillesingulier[indice] + " " + texte;
          } else {
            texte = trois_chiffres(n % 1000) + " " + nmille[indice] + " " + texte;
          }
        }
        n = quotronc(n, 1000);
        indice += 1;
      }
      return texte;
    }
  }
};

Znot = {
  ".inter ": "∩",
  ".intersectionWith ": "∩",
  ".union ": "∪",
  " not in ": "∉",
  " in ": "∈",
  "racine": "√",
  "Math.sqrt": "√",
  "laRacineDe": "√",
  "Infinity": "∞",
  "=": "←",
  "!←": "≠",
  "←←": "=",
  "<←": "≤",
  ">←": "≥",
  "/←": " est divisé par ",
  "\\*←": " est multiplié par ",
  "-←": " est diminué de ",
  "\\+←": " est augmenté de ",
  "\\+\\+": " est incrémenté",
  "--": "est décrémenté",
  " dans ": "∈",
  ".estVide\\(\\)": "=∅",
  ".contains": " ∋ ",
  ".isPerpendicularTo": " ⟂",
  ".isParallelTo": " ∥ ",
  ".subtract": " -",
  ".every": "∀",
  ".some": "∃",
  ".complémentDans": " ∖",
  "->": "↦",
  ".push": " ⇦",
  ".empile": " ⇦",
  ".pop\\(\\)": " ⇨",
  ".ajoute": " ⇦",
  "laSommeDe": "∑",
  ".dot": ".",
  ".angleFrom": "∠",
  ".multiply": "×",
  ".add": "+",
  ".subtract": "-",
  "lEcartTypeDe": "σ",
  "Math.E": "ℯ",
  "for ": "pour ",
  "until ": "jusqu\'à ce que ",
  "while ": "tant que ",
  "if ": "si ",
  "else": "sinon"
};

toMath = function(cs) {
  _.each(Znot, function(value, key) {
    var re;
    re = new RegExp(key, 'g');
    return cs = cs.replace(re, value);
  });
  cs = cs.replace(/\[(\d+)\.\.(\d+)\]/g, "〚$1,$2〛");
  return cs;
};

truchetrond = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "╮╰");
  t = t.replace(/1/g, "╯╭");
  return t;
};

truchet = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "╲");
  t = t.replace(/1/g, "╱");
  return t;
};

truchetortho = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "━");
  t = t.replace(/1/g, "┃");
  return t;
};

truchetgrille = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "╪");
  t = t.replace(/1/g, "╫");
  return t;
};

truchetgrille2 = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "┿");
  t = t.replace(/1/g, "╂");
  return t;
};

truchetpixels = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "▚");
  t = t.replace(/1/g, "▞");
  return t;
};

bincross = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "☐");
  //    t = t.replace /1/g, "☑"
  t = t.replace(/1/g, "☒");
  return t;
};

binpixels = function(binaire) {
  var t;
  t = binaire.replace(/0/g, "⬜");
  t = t.replace(/1/g, "⬛");
  return t;
};

est_minuscule = function(lettre) {
  var n;
  n = lettre.codePointAt(0);
  return (97 <= n && n <= 122);
};

est_majuscule = function(lettre) {
  var n;
  n = lettre.codePointAt(0);
  return (65 <= n && n <= 90);
};

calligraphique = function(texte) {
  var i, k, ref, s;
  s = '';
  for (k = i = 0, ref = texte.length; (0 <= ref ? i <= ref : i >= ref); k = 0 <= ref ? ++i : --i) {
    if (est_minuscule(texte.charAt(k))) {
      s += String.fromCodePoint((texte.charAt(k)).codePointAt(0) + 119945);
    } else {
      if (est_majuscule(texte.charAt(k))) {
        s += String.fromCodePoint((texte.charAt(k)).codePointAt(0) + 119951);
      } else {
        s += texte.charAt(k);
      }
    }
  }
  return s;
};
